# Fonction compos√©e - Correction

> Avant de commencer, sachez qu'il existe toujours plusieurs solutions. 
Si celle se trouvant ci dessous ne correspond pas √† la v√¥tre, elle n'est pas forc√©ment fausse. 
Enjoy !

> √âcrit par [Alexandre Or√©khoff](https://github.com/Hokkaydo)

## Do you know da wae ?

Avant toute chose, il s'agit de bien comprendre l'√©nonc√©.

La premi√®re phrase disait : 

> Je veux que vous √©criviez une fonction capable de construire la fonction compos√©e de plusieurs fonctions

Okey, donc, on doit √©crire une m√©thode capable de d√©terminer et renvoyer la compos√©e de 2+ fonctions.

> Nice, t'as r√©p√©t√© l'√©nonc√©

C'est pour l'avoir bien en t√™te (sisi je vous assure).

On¬†va¬†commencer¬†par¬†appliquer¬†la¬†premi√®re¬†√©tape¬†et¬†faire¬†une¬†**m√©thode**¬†qui¬†peut¬†**composer¬†2¬†fonctions en une¬†seule**.

Il faut donc que notre m√©thode prenne **2 fonctions en param√®tre**. Il faut √©galement que notre m√©thode **renvoie cette fonction compos√©e.**

Pour √©crire ce code, nous allons nous servir du package `java.util.function` et des classes/interfaces qui s'y trouvent, notamment l'interface `Function`.

```java
public Function compose(Function f, Function g) {

}
```

Bon, jusque l√†, pas trop de probl√®me, nous avons la signature de notre m√©thode. Il reste cependant un l√©ger souci, j'ai d√©clar√© mes types de retour et de param√®tre en `rawtypes`. `Rawtype` traduisible par `type brut` en fran√ßais signifie que je n'ai pas sp√©cifi√© les types g√©n√©riques des objets `Function` avec lesquels je vais travailler.

Elles n'acceptent donc par d√©faut que des `Object`. 

---

> Euh wait wait wait, g√©n√©quoi ?

G√©n√©rique

Ne faites pas cette t√™te √©tonn√©e, je vais vous expliquer.

Vous √™tes d'accord avec moi qu'une variable ou une m√©thode, √ßa a besoin de type. Tant pour se d√©finir que pour dire √† quoi on sert.

Vous pouvez par exemple dire que la variable `x`sera de type `int` ce qui signifie qu'elle contiendra un nombre n'est ce pas ?
Vous pouvez √©galement dire que la m√©thode `concat` prendra 2 `String`en param√®tre et renverra un `String`.

Et bien imaginez, si ces types pouvaient varier üòÆ

C'est √† √ßa que servent les types g√©n√©riques. 
Une classe g√©n√©rique se d√©finit comme suit : 

```java
public class MyGenericClass<S, T, U> {

}
```

Ici, j'ai d√©fini 2 variables de types, ce sont mes param√®tres g√©n√©riques. 
Je peux √† pr√©sent faire ceci dans mon code : 

```java
public class MyGenericClass<S, T> {
    T firstVariable;

    public MyGenericClass(S value){
        this.firstVariable = value;
    }
}
```

En effet, je suis s√ªr que `firstVariable` et `value` sont de m√™me type : `S`. Je peux donc faire ce que je veux avec. 

Les listes, ainsi que toutes les classes qui impl√©mentent l'interface `Collection`, sont d'excellents exemples de g√©n√©r√©cit√©.

Je peux √©galement avoir ceci :

```java
public class MyGenericClass<S, T> {
    private S firstVariable;

    public MyGenericClass(S value){
        this.firstVariable = value;
    }

    public T doSomething(S sValue, T tValue) {
        System.out.println(sValue.toString() + tValue.toString() + firstVariable.toString());
        return tValue;
    }
}
```

Ici, lors de l'utilisation de cette m√©thode, je suis s√ªr de r√©cup√©rer en retour un objet du m√™me type que celui pass√© en second param√®tre, ils sont tous les deux de type `T`. 

Un petit exemple rapide de g√©n√©ricit√© pourrait √™tre le suivant :

J'ai une classe `Person` qui repr√©sente une personne lambda. 
 :
```java
public class Person {
    private String name;
    private String surname;
    private int size;
    private int weight;
    
    public Person(String name, String surname, int size, int weight) {
        this.name = name;
        this.surname = surname;
        this.size = size;
        this.weight = weight;
    }
}
```
J'aimerais qu'elle contienne 2 m√©thodes : `getIdentity()` et `getMeasurements()`.
Cependant, comme vous pouvez le remarquer, ces deux m√©thodes sont cens√©es renvoyer chacune 2 param√®tres. `name` et `surname` pour la premi√®re, et `size` et `weight` pour la seconde. Il me faudrait donc cr√©er une classe qui peut agir comme "bo√Æte de stockage" pour renvoyer ces 2 √©l√©ments √† chaque fois :

```java
public Identity {

    private String name;
    private String surname;
    
    public Identity(String name, String surname) {
        this.name = name;
        this.surname = surname;
    }
    
    public String getName() {
        return this.name;
    }
    
    public String getSurname() {
        return this.surname;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public void setSurname(String surname) {
        this.surname = surname;
    }
}
```
Voil√† pour les noms.
Et rebelote ...

```java
public Measurements {

    private int size;
    private int weight;
    
    public Measurements(int size, int weight) {
        this.size = size;
        this.weight = weight;
    }
    
    public int getSize() {
        return this.size;
    }
    
    public int getWeight() {
        return this.weight;
    }
    
    public void setName(int name) {
        this.size = size;
    }
    
    public void setWeight(int weight) {
        this.weight = weight;
    }
    
}
```

Et maintenant, simplement, les m√©thodes qui utilisent ces classes :
```java
public class Person {
    private String name;
    private String surname;
    private int size;
    private int weight;
    
    public Person(String name, String surname, int size, int weight) {
        this.name = name;
        this.surname = surname;
        this.size = size;
        this.weight = weight;
    }
    
    public Identity getIdentity() {
        return new Identity(this.name, this.surname);
    }
    
    public Measurements getMeasurements() {
        return new Measurements(this.size, this.weight);
    }
}
```

Bon.
Techniquement ce code fonctionne...
Le probl√®me ? Eh bien... on se r√©p√®te !!

Vous voyez bien que nos deux classes `Identity` et `Measurements` ont sensiblement la m√™me structure. Seuls leurs types changent.
Bonne nouvelle, c'est l√† que la g√©n√©ricit√© devient utile ;)

La g√©n√©r√©cit√© permet de garder une m√™me structure tout en de changeant les types de param√®tre et de renvoi.

Tout d'abord, la signature de la classe (nom, `modifiers` (`public`, `final` etc), types). Nous essayons de `g√©n√©rifier` 2 classes qui ne travaillent qu'avec un seul type chacune : `String` pour la classe `Identity` et `int` pour la classe `Measurements`.
Donc, r√©sum√© : 1 types, 2 variables. 
2 variables, 2 valeurs, `BiValue` vous semble une bonne id√©e ?

```java
public class BiValue<T> {

}
```

Super
Ici vous voyez donc comment se d√©clare un `type g√©n√©rique` : son nom, qui l'identifiera dans toute la classe, il suit le nom de la classe et il est encadr√© de 2 chevrons. Par convention, on nomme g√©n√©ralement le type g√©n√©rique d'une seule lettre. En fonction du nombre et de l'utilit√© qu'on compte accorder √† ces types, les lettres peuvent changer. En g√©n√©ral :
- Un seul type g√©n√©rique -> `<T>
- Comme seul type g√©n√©rique, on peut √©galement trouver `<R>` pour `Result`, r√©sultat en fran√ßais.
- Une paire de cl√© - valeur (comme une `Map` par exemple) -> `<K, V>` (et oui, pour d√©finir plusieurs types g√©n√©riques, on les s√©pare simplement d'une virugle). `K` pour la cl√©, soit `Key` en anglais et √©videmment `V` pour valeur, `Value` en anglais.
- 2 types -> `<T, U>`
- 3 et 4 types -> `<S, T, U>` et `<S, T, U, V>`
- 5 types et plus (tr√®s rare et g√©n√©ralement pas une bonne id√©e) -> On rajoute une lettre en remontant √† chaque fois d'une lettre en arri√®re dans l'alphabet en partant de `S` (`<R, S, T, U, V>`, etc, ...)

G√©n√©rifions maintenant cette classe :

```java
public class BiValue<T> {
    
    //Comme on ne sait pas ce qu'elle vont contenir, je pr√©f√®re ne pas leur donner de nom trop explicite.
    private T firstValue;
    private T secondValue;
    
    public BiValue(T firstValue, T secondValue) {
        this.firstValue = firstValue;
        this.secondValue = secondValue;
    }
    
    public T getFirstValue() {
        return firstValue;
    }
    public T getSecondValue() {
        return secondValue;
    }
    
    public void setFirstValue(T firstValue) {
        this.firtValue = firstValue;
    }
    public void setSecondValue(T secondValue) {
        this.secondValue = secondValue;
    }
}
```

NI-CKEL
Je peux maintenant r√©utiliser cette classe simplement dans mes 2 m√©thodes `getIdentity()` et `getMeasurements()`. √áa me fera un beau gain d'une classe enti√®re. Et le pied, c'est que cette classe g√©n√©rique est r√©utilisable √† l'infini !

```java
public class Person {
    private String name;
    private String surname;
    private int size;
    private int weight;
    
    public Person(String name, String surname, int size, int weight) {
        this.name = name;
        this.surname = surname;
        this.size = size;
        this.weight = weight;
    }

    public BiValue<String> getIdentiy() {
        //Pour sp√©cifier la valeur du type g√©n√©rique, on le place entre chevrons juste apr√®s le nom de la classe, comme ceci :
        return new BiValue<String>(name, surname);
    }
    public BiValue<Integer> getMeasurements() {
        return new BiValue<Integer>(size, weight);
        //Vous avez s√ªrement remarqu√© que je n'ai pas pr√©cis√© `Integer` *(et non `<int>` car les types primitifs, √† savoir `int`, `double`, `short`, `byte`, `long`. Il faut passer par leurs types `wrapper` : `Integer`, `Double`, `Short`, etc ...)* car le compilateur est assez intelligent pour `inf√©rer`, soit `trouver tout seul`, le type g√©n√©rique √† passer en param√®tre √† `BiValue`. Il peut le d√©duire des param√®tres que nous passons au constructeur 
    }
```

Et voil√†, encore une mission remplie avec succ√®s par **super-g√©n√©rique**. 
Bref, les types g√©n√©riques sont des types pouvant varier d'une instance de classe √† l'autre **mais qui restent constants au sein d'une m√™me instance**.

---

Bon c'est pas tout √ßa mais corrigeons cela :

```java
public Function<Integer, Integer> compose(Function<Integer, Integer> f, Function<Integer, Integer> g) {

}
```

---

Au fait, dernier interlude g√©n√©ricit√© : 
L'interface `Function`est un super exemple de g√©n√©ricit√© aussi. Son but, c'est de pouvoir contenir une m√©thode qui prend quelque chose en param√®tre et qui renvoie quelque chose. 
Sauf qu'on ne connait pas ces fameux quelque chose. 
Les types sont donc g√©n√©riques et il faut le pr√©ciser.

Voici le code de cette, si renomm√©e, interface `Function` :
```java
public interface Function<T, R> {
    R apply(T t);
} 
```
Vous voyez qu'elle a besoin de 2 types g√©n√©riques : un type quelconque (`<T>`) et un type de r√©sultat (`<R>`).
Afin de comprendre son fonctionnement, je vous sugg√®re de jeter un coup d'oeil √† [cette fiche](https://github.com/readthedocs-fr/notions/tree/master/java/interfaces_fonctionnelles) sur les interfaces fonctionnelles dont notre ch√®re et bien-aim√©e interface `Function` fait partie .

Mon type de retour est ici un objet de type `Function` et cette fonction prend en param√®tre un nombre et renvoie un nombre. √á'aurait pu √™tre n'importe quoi d'autre, une fonction qui prend un `String`en param√®tre et renvoie un `Double`etc...

---

Nickel.

L'√©tape suivante, c'est de renvoyer une fonction.

Pour cela nous allons utiliser la forme suivante :

`x -> y`

Elle signifie "Cette fonction prend une valeur x et renvoie une valeur y". Encore une fois, je vous invite √† lire la fiche sur les [interfaces fonctionnelles en java](https://github.com/readthedocs-fr/notions/tree/master/java/interfaces_fonctionnelles) si cette syntaxe vous est inconnue.

Go :

```java
public Function<Integer, Integer> compose(Function<Integer, Integer> f, Function<Integer, Integer> g) {
    Function<Integer, Integer> h = x -> 0;
}
```

Notre fonction `h` prend actuellement un nombre en param√®tre et renvoie `0`.

Or ce n'est pas notre but.

Nous voulons faire en sorte que le param√®tre de `h` passe √† travers la moulinette de la fonction `g` puis √† travers celle de `f` et qu'elle soit enfin renvoy√©e.

La classe `Function` nous met √† disposition une m√©thode `apply` qui prend en param√®tre une valeur (dont le type est sp√©cifi√© par la classe g√©n√©rique, `Integer` dans notre cas soit un nombre).

Nous pourrions donc faire 

`g.apply(x)` 

et nous r√©cup√®rerions un nombre non ?

Faisons le :

```java
public Function<Integer, Integer> compose(Function<Integer, Integer> f, Function<Integer, Integer> g) {
    Function<Integer, Integer> h = x -> g.apply(x);
}
```

Maintenant, `h` fait le m√™me travail que `g`. 

Inutile donc 

Il nous faut encore passer le r√©sultat de `g.apply(x)` dans la moulinette de `f`.

Qu'est ce qu'on attend ?

```java
public Function<Integer, Integer> compose(Function<Integer, Integer> f, Function<Integer, Integer> g) {
    Function<Integer, Integer> h = x -> f.apply(g.apply(x));
}
```

Enfin !

Nous avons notre fonction compos√©e `h` pr√™te √† l'emploi.

Suffit de terminer le travail et de rendre √† C√©sar ce qui est √† C√©sar (ou plut√¥t √† notre m√©thode) :

```java
public Function<Integer, Integer> compose(Function<Integer, Integer> f, Function<Integer, Integer> g) {
    Function<Integer, Integer> h = x -> f.apply(g.apply(x));
    return h;
}
```

Nous pouvons d'ailleurs sauter le passage en variable de `h`. Nous gagnons ainsi une ligne.

```java
public Function<Integer, Integer> compose(Function<Integer, Integer> f, Function<Integer, Integer> g) {
    return x -> f.apply(g.apply(x));
}
```

---

**1√®re √©tape ‚úÖ**

---

## √âtape interm√©diaire

Maintenant que vous commencez √† comprendre le fonctionnement, nous allons passer √† la vitesse sup√©rieure (don't worry je suis l√† üëÄ).

Cette deuxi√®me √©tape est d√©finie par l'extension √† l'illimit√©√©√© (ü§©). 

Comme je vous l'avais sugg√©r√©, nous allons passer par une liste de fonctions.

Reprenons sans plus attendre la signature de la m√©thode pr√©c√©dente et adaptons l√† :

```java
public Function<Integer, Integer> compose(List<Function<Integer, Integer>> functions) {

}
```

√Ä ce stade ci, nous avons d√©sormais 2 possibilit√©s :

- Soit nous allons vers une partie simple et sans d√©couverte en faisant une simple boucle sur la liste et en les appliquant les unes sur les autres (pas fun fun tout √ßa)
- Soit nous allons vers le monde merveilleux de la r√©cursivit√© et on fait des choses grandioses üòç

(√âvidemment, dans cette correction, vous n'avez pas le choix, c'est moi qui d√©cide ce que j'√©cris et je d√©cide de partir sur la deuxi√®me option üëÄ)

*N√©anmoins,¬†comme¬†dit¬†au¬†d√©but,¬†toute¬†solution¬†qui¬†fonctionne¬†est¬†une¬†solution¬†correcte,¬†il¬†n'y¬†a¬†pas¬†de¬†solution¬†meilleure¬†que¬†toutes¬†les¬†autres. Si¬†vous¬†avez¬†choisi¬†de¬†partir¬†sur¬†les¬†boucles,¬†bien¬†vu,¬†c'est¬†d√©j√†¬†nickel¬†d'√™tre¬†arriv√©¬†jusqu'ici.¬†Vous¬†avez¬†r√©ussi¬†l'exercice.¬†Mais¬†regardez¬†quand¬†m√™me¬†ce¬†que¬†√ßa¬†donne¬†sous¬†une¬†autre¬†forme,¬†√ßa¬†ne¬†peut¬†√™tre¬†que¬†b√©n√©fique*¬†üòá

### Interlude r√©cursivit√©

Expliquons vite fait ce qu'est la r√©cursivit√© pour ceux qui ne connaissent pas.

Quelque¬†chose¬†de¬†r√©cursif,¬†c'est¬†quelque¬†chose¬†qui¬†fait¬†tout¬†le¬†temps¬†appel¬†√†¬†lui¬†m√™me¬†jusqu'√†¬†ce¬†que¬†la¬†boucle¬†d'appel¬†se¬†casse¬†ou¬†soit¬†stopp√©e.

√áa peut √™tre une liste, une m√©thode, une mani√®re de parcourir un objet it√©rable, etc.

---

Nous allons donc construire une m√©thode qui va se rappeler √† l'infini tant qu'on ne l'arr√™te pas. 

Pour l'arr√™ter, il faut une condition exutoire *(de sortie)*. Cette condition doit √™tre le point √† partir duquel la m√©thode ne peut plus se rappeler car soit cela causerait un bug soit car tout simplement √ßa ne sert plus √† rien.

Ici, nous allons faire en sorte que la m√©thode se rappelle tant qu'il y a des fonctions √† traiter dans la liste qu'on lui passe en param√®tre.

Notre m√©thode va traiter une condition avec la suivante, une fois qu'elles auront √©t√© compos√©es en une nouvelle fonction, celle ci se verra ajout√©e √† la fin de la liste afin qu'on puisse la r√©cup√©rer.

Notre condition, c'est donc qu'il ne reste qu'une seule fonction dans la liste (notre fonction compos√©e).

Si cette condition est atteinte, cela signifie que la seule m√©thode de la liste est la m√©thode √† renvoyer.

```java
public Function<Integer, Integer> compose(List<Function<Integer, Integer>> functions) {
¬†¬†¬†¬†if(functions.size()¬†==¬†1)¬†{
        return functions.get(0);
    }
}
```

Tant qu'on est dans les conditions, pensons au cas o√π l'utilisateur fournit une liste vide. Notre m√©thode ne pouvons composer de fonction sans fonctions. Renvoyons simplement une fonction qui renvoie toujours 0.

```java
public Function<Integer, Integer> compose(List<Function<Integer, Integer>> functions) {
    if(funcitons.size() == 1) {
        return functions.get(0);
    }
    
    if(functions.size() == 0) {
        return x -> x; //la forme x-> y
    }
}
```

Maintenant construisons le corps m√™me de la fonction.

Il faut donc commencer par la fin puisque la premi√®re fonction de la liste est la derni√®re √† √™tre appliqu√©e *`a(b(c(d(...(x)))))`.* Cela nous permettra √©galement de r√©cup√©rer facilement la derni√®re fonction compos√©e cr√©√©e vu qu'elle sera ajout√©e en fin de liste et prendra la place des 2 derni√®res pr√©c√©dentes.

```java
public Function<Integer, Integer> compose(List<Function<Integer, Integer>> functions) {
    if(funcitons.size() == 1) {
        return functions.get(0);
    }
    
    if(functions.size() == 0) {
        return x -> x; //la forme x-> y
    }
    
    //Nous r√©cup√©rons et supprimons les 2 fonctions de la liste
    //La derni√®re fonction de la liste est celle 
    //qu'il faut appliquer en premier sur notre variable, 
    //on la nomme donc g. F est la seconde fonction.
    Function<Integer, Integer> g = functions.remove(functions.size() - 1);
    Function<Integer, Integer> f = functions.remove(functions.size() - 1);
    
    //Rien de nouveau sous le soleil, c'est l'√©tape 1
    Function<Integer, Integer> h = x -> f.apply(g.apply(x));

    functions.add(h);

    return compose(functions);
}
```

Et voil√†, notre m√©thode `compose()` est termin√©e.

Normalement sur le milieu du code, vous devriez pouvoir vous en sortir vous m√™me pour comprendre.

La derni√®re ligne, `return compose(functions);` , peut √™tre plus coriace.

C'est justement l√† toute la magie de la r√©cursivit√©.

Comme nous avons d√©fini un point d'arr√™t plus haut, nous pouvons rappeler notre m√©thode ind√©finiment tant qu'elle ne valide pas la condition de stop.

Nous pouvons renvoyer notre propre m√©thode car comme vous le voyez, et c'est plut√¥t logique, les types de retour concordent. 
C'est normal vu que c'est la m√™me m√©thode. 
Nous pouvons √©galement lui passer l'ancienne liste maintenant modifi√©e en param√®tre. 
L'appel n¬∞2 de la m√©thode fera son travail (elle devra peut-√™tre demander un 3i√®me appel de m√©thode et ainsi de suite) puis renverra la bonne valeur √† la m√©thode de l'appel n¬∞1 qui, elle, renverra la valeur √† l'endroit duquel elle a √©t√© appel√©e pour la premi√®re fois.

## Final sprint

Arriv√© ici, ce ne sera qu'une simple formalit√© pour vous qui avez compris comment fonctionnait le principe de r√©cursivit√©.

Nous devons ici simplement *g√©n√©raliser* notre m√©thode.

Par g√©n√©raliser, j'entends √©videmment *g√©n√©rifier*.

C'est √† dire, rendre cette m√©thode applicable √† tout type d'√©l√©ment en appliquant ce qu'on appelle des param√®tres g√©n√©riques.

Nous allons donc d√©finir 2 param√®tres : l'entr√©e et la sortie. En anglais on dit `input` et `output`. Par convention, les noms de param√®tre g√©n√©rique ne sont compos√©s que d'une seule lettre. Ce sera donc `I` et `O`.

Premi√®rement, nous d√©finissons nos param√®tres pour la m√©thode :

---

Car oui, une classe mais √©galement une m√©thode peuvent d√©finir des types g√©n√©riques. La classe les d√©finira pour toutes les m√©thodes et variables qu'elle contient, tandis que les param√®tres de la m√©thode g√©n√©rique resteront cantonn√©s √† la r√©gion locale, soit le corps de la m√©thode. Une fois que la m√©thode a termin√© de s'ex√©cuter, ces param√®tres g√©n√©riques ne valent plus rien.

Pour d√©finir des types g√©n√©riques dans une m√©thode, on passe, comme pour les classes, les noms des diff√©rents param√®tres entre chevrons (`<` `>`) juste apr√®s les `modifiers`de la m√©thode (`public`, `private`, `synchronized`, etc ...)

---

```java
public <I, O> Function<Integer, Integer> compose(List<Function<Integer, Integer>> functions) {
    if(funcitons.size() == 1) {
        return functions.get(0);
    }
    
    if(functions.size() == 0) {
        return x -> x; 
    }
    
    Function<Integer, Integer> g = functions.remove(functions.size() - 1);
    Function<Integer, Integer> f = functions.remove(functions.size() - 1);
    
    Function<Integer, Integer> h = x -> f.apply(g.apply(x));

    functions.add(h);

    return compose(functions);
}
```

Dans chacune de nos fonctions, nous avons d√©clar√© que les types d'entr√©e et de sortie √©taient tous les deux des nombres. Rempla√ßons √ßa :

```java
public <I, O> Function<I, O compose(List<Function<I, O>> functions) {
    if(funcitons.size() == 1) {
        return functions.get(0);
    }
    
    if(functions.size() == 0) {
        return x -> x; 
    }
    
    Function<I, O> g = functions.remove(functions.size() - 1);
    Function<I, O> f = functions.remove(functions.size() - 1);
    
    Function<I, O> h = x -> f.apply(g.apply(x));

    functions.add(h);

    return compose(functions);
}
```

Impeccable.

D√©sormais, notre m√©thode peut composer un nombre illimit√© de fonction en une seule fonction tant qu'elle gardent le m√™me type de param√®tre et de retour.

## Conclusion

Cette *correction* touche √† sa fin.

L'exercice n'√©tait pas simple, f√©licitation √† ceux qui l'ont r√©ussi, un grand bravo √† tout ceux qui ont essay√© de le faire *(le plus important n'est pas de trouver la solution mais de r√©fl√©chir)*. 

J'esp√®re que √ßa vous a bien fait r√©fl√©chir, que √ßa vous a plu et que surtout vous avez appris des choses üòõ 

On se retrouve bient√¥t pour quelque chose de tout aussi croustillant ;)
